import { EntityManager } from '@mikro-orm/postgresql';
import { BadRequestException, Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { JwtService } from '@nestjs/jwt';
import { AppAuthConfig, UserJwtPayload } from '@newbee/api/auth/util';
import { AuthenticatorService } from '@newbee/api/authenticator/data-access';
import { UserEntity } from '@newbee/api/shared/data-access';
import { UserChallengeService } from '@newbee/api/user-challenge/data-access';
import {
  authenticatorVerifyBadRequest,
  challengeFalsy,
} from '@newbee/shared/util';
import type { VerifiedAuthenticationResponse } from '@simplewebauthn/server';
import {
  generateAuthenticationOptions,
  verifyAuthenticationResponse,
} from '@simplewebauthn/server';
import type {
  AuthenticationResponseJSON,
  AuthenticatorDevice,
  PublicKeyCredentialDescriptorFuture,
  PublicKeyCredentialRequestOptionsJSON,
} from '@simplewebauthn/typescript-types';

/**
 * The service that logs in and registers users.
 */
@Injectable()
export class AuthService {
  private readonly logger = new Logger(AuthService.name);

  constructor(
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService<AppAuthConfig, true>,
    private readonly em: EntityManager,
    private readonly authenticatorService: AuthenticatorService,
    private readonly userChallengeService: UserChallengeService
  ) {}

  /**
   * Creates an access token for the given user.
   *
   * @param user The user to create an access token for.
   *
   * @returns The access token.
   */
  login(user: UserEntity): string {
    const payload: UserJwtPayload = { sub: user.id };
    return this.jwtService.sign(payload);
  }

  /**
   * Generate a login challenge for use in WebAuthn authentication.
   *
   * @param email The email of the user attempting to log in.
   *
   * @returns The options needed for the frontend for starting the WebAuthn authentication process.
   * @throws {NotFoundException} `userChallengeEmailNotFound`. If the ORM throws a `NotFoundError`.
   * @throws {InternalServerErrorException} `internalServerError`. For any other error.
   */
  async generateLoginChallenge(
    email: string
  ): Promise<PublicKeyCredentialRequestOptionsJSON> {
    const allowCredentials: PublicKeyCredentialDescriptorFuture[] = (
      await this.authenticatorService.findAllByEmail(email)
    ).map(({ credentialId, transports }) => ({
      id: Buffer.from(credentialId, 'base64url'),
      type: 'public-key',
      ...(transports && { transports }),
    }));

    const options = generateAuthenticationOptions({
      allowCredentials,
      userVerification: 'preferred',
      rpID: this.configService.get('rpInfo.id', { infer: true }),
    });
    await this.userChallengeService.updateByEmail(email, options.challenge);
    return options;
  }

  /**
   * Verify the frontend's response to the backend's WebAuthn login challenge.
   *
   * @param email The email of the user attempting to log in.
   * @param response The credential generated by the frontend.
   *
   * @returns The `UserEntity` instance associated with the user, if the challenge is valid and verified.
   * @throws {NotFoundException} `userChallengeEmailNotFound`, `authenticatorCredentialIdNotFound`, `authenticatorIdNotFound`.
   * If the user challenge cannot be found by email or the authenticator cannot be found by credential ID nor ID.
   * @throws {BadRequestException} `authenticatorVerifyBadRequest`. If the challenge can't be verified.
   * @throws {InternalServerErrorException} `internalServerError`. For any other type of error.
   */
  async verifyLoginChallenge(
    email: string,
    response: AuthenticationResponseJSON
  ): Promise<UserEntity> {
    const userChallenge = await this.userChallengeService.findOneByEmail(email);
    await this.em.populate(userChallenge, ['user']);
    const { user, challenge } = userChallenge;
    if (!challenge) {
      this.logger.error(challengeFalsy('login', challenge, user.id));
      throw new BadRequestException(authenticatorVerifyBadRequest);
    }

    const { id } = response;
    const authenticator = await this.authenticatorService.findOneByCredentialId(
      id
    );
    const { credentialPublicKey, credentialId, counter, transports } =
      authenticator;
    const authenticatorDevice: AuthenticatorDevice = {
      credentialPublicKey: Buffer.from(credentialPublicKey, 'base64url'),
      credentialID: Buffer.from(credentialId, 'base64url'),
      counter,
      ...(transports && { transports }),
    };

    const rpInfo = this.configService.get('rpInfo', { infer: true });
    let verification: VerifiedAuthenticationResponse;
    try {
      verification = await verifyAuthenticationResponse({
        response,
        expectedChallenge: challenge,
        expectedOrigin: rpInfo.origin,
        expectedRPID: rpInfo.id,
        authenticator: authenticatorDevice,
      });
    } catch (err) {
      this.logger.error(err);
      throw new BadRequestException(authenticatorVerifyBadRequest);
    }

    const { verified, authenticationInfo } = verification;
    if (!verified) {
      this.logger.error(`Could not verify credentials for user: ${user.id}`);
      throw new BadRequestException(authenticatorVerifyBadRequest);
    }

    await this.authenticatorService.updateCounterById(
      authenticator.id,
      authenticationInfo.newCounter
    );
    return user;
  }
}
